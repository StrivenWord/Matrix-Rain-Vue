<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Code Rain v2.0</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            color: #0f0;
            background-color: rgba(0, 0, 0, 0.9);
            padding: 15px;
            padding-top: 70px;
            height: 100vh;
            max-width: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            transition: transform 0.3s ease-in-out;
            scrollbar-width: thin;
            scrollbar-color: #0f0 rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        #toolbar::-webkit-scrollbar {
            width: 8px;
        }
        #toolbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.5);
        }
        #toolbar::-webkit-scrollbar-thumb {
            background-color: #0f0;
            border-radius: 4px;
        }
        #toolbar.hidden {
            transform: translateX(-100%);
        }
        button, select {
            background-color: #0f0;
            color: #000;
            border: none;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        input[type="range"] {
            width: 100%;
        }
        #toggleToolbar {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            width: 40px;
            height: 40px;
            background-color: #0f0;
            border: none;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3),
                        inset 0 0 15px rgba(255, 255, 255, 0.2);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        #toggleToolbar::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                120deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transition: 0.5s;
        }
        #toggleToolbar:hover::before {
            left: 100%;
        }
        #toggleToolbar:hover {
            background-color: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5),
                        inset 0 0 15px rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        #toggleToolbar:active {
            transform: scale(0.95);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.4),
                        inset 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .section {
            margin-bottom: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }
        .section-header {
            cursor: pointer;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 255, 0, 0.1);
            border-radius: 4px;
            margin: -10px -10px 10px -10px;
        }
        .section-header:hover {
            background: rgba(0, 255, 0, 0.15);
        }
        .section-content {
            max-height: 0;
            overflow: visible;
            transition: max-height 0.3s ease-out;
            opacity: 0;
            display: none;
            position: relative;
        }
        .section-content.visible {
            max-height: none;
            opacity: 1;
            transition: max-height 0.5s ease-in, opacity 0.3s ease-in;
            display: block;
        }
        .section h3 {
            margin: 0;
            font-size: 14px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .section-arrow {
            transition: transform 0.3s ease;
        }
        .section-content:not(.visible) + .section-header .section-arrow {
            transform: rotate(-90deg);
        }
        /* Add padding to the top to account for the toggle button */
        .section:first-child {
            margin-top: 50px;
        }
        label {
            display: block;
            margin-top: 10px;
        }
        #resetButton {
            background-color: #ff4500;
            color: white;
            font-weight: bold;
            margin-top: 15px;
        }
        .character-density-container {
            margin-top: 10px;
            margin-left: 20px;
        }
        .character-selector-container {
            position: relative;
            display: inline-block;
            z-index: 1001;
        }
        .character-selector {
            position: absolute;
            left: 0;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid #0f0;
            padding: 8px;
            width: 180px;
            z-index: 1001;
            backdrop-filter: blur(3px);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.2);
            display: none;
        }
        .character-selector.visible {
            display: block;
        }
        #charSelectorBtn {
            width: 180px;
            margin-bottom: 5px;
            text-align: left;
            position: relative;
            padding: 4px 24px 4px 8px;
            font-size: 12px;
        }
        #charSelectorBtn:after {
            content: '▼';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        #charSelectorBtn.active:after {
            content: '▲';
        }
        .character-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin-bottom: 6px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.95);
        }
        .char-box {
            border: 1px solid #0f0;
            text-align: center;
            cursor: pointer;
            color: #0f0;
            background: rgba(0, 0, 0, 0.5);
            transition: all 0.2s ease;
            font-size: 12px;
            width: 20px;
            height: 20px;
            line-height: 18px;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .char-box:hover {
            background: rgba(0, 255, 0, 0.1);
            transform: scale(1.1);
        }
        .char-box.selected {
            background: rgba(0, 255, 0, 0.3);
            color: #fff;
            text-shadow: 0 0 5px #0f0;
        }
        .selector-controls {
            display: flex;
            gap: 4px;
            margin-top: 6px;
            width: 100%;
            border-top: 1px solid rgba(0, 255, 0, 0.2);
            padding-top: 6px;
        }
        .selector-controls button {
            flex: 1;
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid #0f0;
            color: #0f0;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            min-width: 60px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .selector-controls button:hover {
            background: rgba(0, 255, 0, 0.3);
        }
        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1;
            display: none;
        }
        #matrix {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
        /* Add transition for the toggle button position */
        #toggleToolbar {
            transition: all 0.3s ease-in-out;
        }
        /* Move toggle button when toolbar is visible */
        #toolbar:not(.hidden) + #toggleToolbar {
            left: calc(100% - 60px);
        }
        /* New styles for sequence controls */
        .sequence-controls {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .sequence-input {
            width: 100%;
            margin-top: 5px;
            background: rgba(0, 0, 0, 0.3);
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px;
        }
        
        .trail-controls {
            margin-top: 10px;
        }
        
        .ripple {
            animation: rippleEffect 0.5s ease-out;
        }
        
        @keyframes rippleEffect {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        .color-cycle {
            transition: color 0.5s ease;
        }
    </style>
</head>
<body>
    <div class="fps-counter" id="fpsCounter">FPS: 0</div>
    <canvas id="matrix"></canvas>
    <canvas id="gridCanvas"></canvas>
    <button id="toggleToolbar" onclick="toggleToolbar()">☰</button>
    <div id="toolbar" class="hidden">
        <div class="section" id="controls-section">
            <div class="section-header" onclick="toggleSection('controls-section')">
                <h3>Controls</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <button onclick="togglePause()">Pause/Resume</button>
                <button onclick="randomizeColor()">Random Color</button>
                <input type="color" id="colorPicker" value="#00ff00" onchange="updateColor(this.value)">
                <label>Speed:
                    <input type="range" id="speedSlider" min="10" max="200" value="50" onchange="updateSpeed(this.value)">
                </label>
                <label>Fade Speed:
                    <input type="range" id="fadeSpeedSlider" min="0.01" max="0.2" step="0.01" value="0.05" onchange="updateFadeSpeed(this.value)">
                </label>
                <label>Font Size:
                    <input type="range" id="fontSizeSlider" min="10" max="50" value="20" onchange="updateFontSize(this.value)">
                </label>
            </div>
        </div>

        <div class="section" id="character-section">
            <div class="section-header" onclick="toggleSection('character-section')">
                <h3>Character Settings</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <label>Character Set:
                    <select id="charSetSelect" onchange="updateCharacterSet(this.value)">
                        <option value="matrix">Matrix (Katakana + Latin)</option>
                        <option value="binary">Binary (0/1)</option>
                        <option value="ascii">ASCII</option>
                        <option value="custom">Custom</option>
                    </select>
                </label>
                <div id="customCharSetControls" style="display: none;">
                    <label>Custom Characters:
                        <input type="text" id="customCharInput" onchange="updateCustomCharSet(this.value)">
                    </label>
                </div>
                <div class="character-selector-container">
                    <button id="charSelectorBtn" onclick="toggleCharacterSelector(event)">Show Characters</button>
                    <div id="characterSelector" class="character-selector">
                        <div id="characterGrid" class="character-grid"></div>
                        <div class="selector-controls">
                            <button onclick="selectAllCharacters()">Select All</button>
                            <button onclick="deselectAllCharacters()">Deselect All</button>
                        </div>
                    </div>
                </div>
                <label style="display: flex; align-items: center; margin-top: 10px;">
                    Character Change Interval:
                    <div style="margin-left: 10px;">
                        <input type="number" id="minLineChange" value="1" min="1" style="width: 50px" onchange="updateLineChangeRange()">
                        <input type="range" id="lineChangeSlider" value="1" onchange="updateLineChangeRate(this.value)">
                        <input type="number" id="maxLineChange" value="4" min="1" style="width: 50px" onchange="updateLineChangeRange()">
                    </div>
                </label>

                <!-- Add sequence controls here -->
                <div class="sequence-section" style="margin-top: 15px; border-top: 1px solid #0f0; padding-top: 15px;">
                    <label><input type="checkbox" id="sequenceCheckbox" onchange="toggleSequence(this.checked)">Enable Sequence Mode</label>
                    <div id="sequenceControls" style="display: none; margin-top: 10px;">
                        <label>Sequence Mode:
                            <select id="sequenceModeSelect" onchange="updateSequenceMode(this.value)">
                                <option value="random">Random</option>
                                <option value="orderly">Orderly</option>
                                <option value="sequential">Sequential</option>
                            </select>
                        </label>
                        <div id="sequentialControls" style="display: none; margin-top: 10px;">
                            <label>Custom Sequence:
                                <input type="text" id="customSequenceInput" class="sequence-input" 
                                       placeholder="Enter sequence (e.g., ABC123)"
                                       onchange="updateCustomSequence(this.value)">
                            </label>
                        </div>
                        <div class="trail-controls">
                            <label>Trail Length:
                                <input type="range" id="trailLengthSlider" min="1" max="10" value="3"
                                       onchange="updateTrailLength(this.value)">
                                <span id="trailLengthValue">3</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="effects-section">
            <div class="section-header" onclick="toggleSection('effects-section')">
                <h3>Visual Effects</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <label><input type="checkbox" id="gradientCheckbox" onchange="toggleGradient(this.checked)">Gradient Mode</label>
                <label><input type="checkbox" id="glowCheckbox" onchange="toggleGlow(this.checked)">Character Glow</label>
                <label><input type="checkbox" id="colorCycleCheckbox" onchange="toggleColorCycle(this.checked)">Color Cycling</label>
                <div id="colorCycleControls" style="display: none; margin-left: 20px;">
                    <label>Color Cycle Speed (seconds):
                        <input type="range" id="colorSpeedSlider" min="0.1" max="5" step="0.1" value="2"
                               onchange="updateColorSpeed(this.value)">
                        <span id="colorSpeedValue">2.0</span>
                    </label>
                </div>
                <label>
                    <input type="checkbox" id="gridCheckbox" onchange="toggleGrid(this.checked)">Grid Effect
                    <div style="margin-left: 20px; display: none;" id="gridControls">
                        <label>Grid Color:
                            <input type="color" id="gridColorPicker" value="#00ff00" onchange="updateGridColor(this.value)">
                        </label>
                        <label>Grid Opacity:
                            <input type="range" id="gridOpacitySlider" min="0.01" max="0.5" step="0.01" value="0.15" 
                                   onchange="updateGridOpacity(this.value)">
                        </label>
                    </div>
                </label>
                <label>
                    <input type="checkbox" id="particleCheckbox" onchange="toggleParticles(this.checked)">Particle Effect
                    <div style="margin-left: 20px; display: none;" id="particleControls">
                        <label>Particle Color:
                            <input type="color" id="particleColorPicker" value="#00ff00" onchange="updateParticleColor(this.value)">
                        </label>
                    </div>
                </label>
                <label>
                    <input type="checkbox" id="lightingCheckbox" onchange="toggleLighting(this.checked)">Lighting Effect
                    <div style="margin-left: 20px; display: none;" id="lightingControls">
                        <label>Lighting Color:
                            <input type="color" id="lightingColorPicker" value="#00ff00" onchange="updateLightingColor(this.value)">
                        </label>
                    </div>
                </label>
                <label>Theme:
                    <select id="themeSelect" onchange="updateTheme(this.value)">
                        <option value="matrix">Matrix Green</option>
                        <option value="cyberpunk">Cyberpunk</option>
                        <option value="neon">Neon</option>
                        <option value="monochrome">Monochrome</option>
                    </select>
                </label>
                <label>Gradient Preset:
                    <select id="gradientPresetSelect" onchange="updateGradientPreset(this.value)">
                        <option value="custom">Custom</option>
                        <option value="cyber">Cyber</option>
                        <option value="neon">Neon</option>
                        <option value="matrix2">Matrix 2.0</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="section" id="movement-section">
            <div class="section-header" onclick="toggleSection('movement-section')">
                <h3>Movement Controls</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <label><input type="checkbox" id="movementCheckbox" onchange="toggleMovement(this.checked)">Enable Movement Controls</label>
                <div id="movementControls" style="display: none; margin-top: 10px;">
                    <label>Horizontal Movement:
                        <input type="range" id="horizontalMovementSlider" min="0" max="10" value="0" 
                               onchange="updateHorizontalMovement(this.value)">
                        <span id="horizontalMovementValue">0</span>
                    </label>
                    <label>Movement Range (pixels):
                        <input type="number" id="movementRangeInput" min="1" value="15" style="width: 60px"
                               onchange="updateMovementRange(this.value)">
                    </label>
                    <label>Precipitation Mode:
                        <select id="precipitationSelect" onchange="updatePrecipitationMode(this.value)">
                            <option value="continuous">Continuous Stream</option>
                            <option value="individual">Individual Rain Lines</option>
                            <option value="single">Single Line Per Cycle</option>
                            <option value="dense">Dense Packed Rain</option>
                        </select>
                    </label>
                    <label>Density Control:
                        <input type="range" id="densitySlider" min="0" max="10" value="5" 
                               onchange="updateDensity(this.value)">
                        <span id="densityValue">5</span>
                    </label>
                    <div id="precipitationControls" style="margin-left: 20px;">
                        <label>Spawn Delay (Individual/Single Mode):
                            <input type="range" id="spawnDelaySlider" min="200" max="1500" value="500" 
                                   onchange="updateSpawnDelay(this.value)">
                            <span id="spawnDelayValue">0.5s</span>
                        </label>
                        <label>Line Spacing (Individual Mode):
                            <input type="range" id="lineSpacingSlider" min="2" max="10" value="4" 
                                   onchange="updateLineSpacing(this.value)">
                            <span id="lineSpacingValue">4</span>
                        </label>
                        <div id="denseControls" style="display: none;">
                            <label>Dense Pack Intensity:
                                <input type="range" id="densePackSlider" min="1" max="20" value="3" 
                                       onchange="updateDensePack(this.value)">
                                <span id="densePackValue">3</span>
                            </label>
                            <label>Trail Character Count:
                                <input type="range" id="trailCharSlider" min="1" max="10" value="3" 
                                       onchange="updateTrailChars(this.value)">
                                <span id="trailCharValue">3</span>
                            </label>
                        </div>
                        <label>Line Variation:
                            <input type="range" id="lineVariationSlider" min="0" max="100" value="30" 
                                   onchange="updateLineVariation(this.value)">
                            <span id="lineVariationValue">30%</span>
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="waterfall-section">
            <div class="section-header" onclick="toggleSection('waterfall-section')">
                <h3>Waterfall Mode</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <label><input type="checkbox" id="waterfallCheckbox" onchange="toggleWaterfall(this.checked)">Enable Waterfall Mode</label>
                <div id="waterfallControls" style="display: none; margin-top: 10px;">
                    <label>Waterfall Intensity:
                        <input type="range" id="waterfallIntensitySlider" min="0" max="100" value="50" 
                               onchange="updateWaterfallIntensity(this.value)">
                        <span id="waterfallIntensityValue">50</span>
                    </label>
                    <div style="margin-top: 5px; font-size: 12px; color: #0f0;">
                        Low: Varied falling speed - High: Uniform falling speed
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="system-section">
            <div class="section-header" onclick="toggleSection('system-section')">
                <h3>System Controls</h3>
                <span class="section-arrow">▼</span>
            </div>
            <div class="section-content">
                <button onclick="toggleFullscreen()">Toggle Fullscreen</button>
                <button onclick="saveSettings()">Save Settings</button>
                <button onclick="loadSettings()">Load Settings</button>
                <button id="resetButton" onclick="resetToDefaults()">Reset to Defaults</button>
            </div>
        </div>
    </div>

    <audio id="backgroundSound" loop>
        <source src="rain.mp3" type="audio/mpeg" />
        Your browser does not support the audio element.
    </audio>

    <script>
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        let animationFrameId;
        let lastFrameTime = Date.now();
        let fps = 0;

        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;
        gridCanvas.height = window.innerHeight;
        gridCanvas.width = window.innerWidth;

        let katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヰヱヲン';
        let latin = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
        let nums = '0123456789';

        let alphabet = katakana + latin + nums;

        let fontSize = 16;
        let columns = canvas.width / fontSize;

        let rainDrops = [];
        let rainDropsChars = [];
        for (let x = 0; x < columns; x++) {
            rainDrops[x] = 1;
            rainDropsChars[x] = alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        }

        let color = '#00f';
        let speed = 50;
        let paused = false;
        let fadeSpeed = 0.05;
        let lineChangeRate = 1; // Number of lines to pass before changing character
        let minLineChange = 1;
        let maxLineChange = 4;
        let interval;

        let particles = [];
        const PARTICLE_LIFETIME = 100;
        let gradientColors = null;

        let selectedChars = new Set(); // Store selected characters

        let gradientMode = false;
        let glowEnabled = false;
        let gridEnabled = false;
        let particlesEnabled = false;
        let lightingEnabled = false;

        let gridColor = '#00ff00';
        let gridOpacity = 0.15;

        let particleColor = '#00ff00';
        let lightingColor = '#00ff00';

        let sequenceEnabled = false;
        let sequenceMode = 'random';
        let customSequence = '';
        let trailLength = 3;
        let colorCycleSpeed = 2;
        let colorCycleEnabled = false;
        let currentSequenceIndex = 0;
        let lastColorChange = Date.now();

        // Add new variables for movement controls
        let movementEnabled = false;
        let horizontalMovement = 0;
        let precipitationMode = 'continuous';
        let spawnDelay = 500;
        let lineSpacing = 4;
        let columnOffsets = [];
        let lastSpawnTimes = [];
        let columnPhases = [];
        let currentColumn = 0; // For single line mode

        // Add new variables for enhanced movement controls
        let density = 5;
        let columnVelocities = [];
        let columnGaps = [];
        let baseVerticalSpeed = 80; // pixels per second

        // Add new variable for movement range
        let movementRange = 15; // Default 15 pixels

        // Add new variables for enhanced density controls
        let densePack = 3;
        let trailChars = 3;
        let lineVariation = 30;
        let columnDelays = [];

        // Add new waterfall variables
        let waterfallEnabled = false;
        let waterfallIntensity = 50; // Default middle value
        let columnSpeeds = [];

        // Initialize column-specific variables
        function initializeColumns() {
            columnOffsets = new Array(Math.ceil(columns)).fill(0);
            lastSpawnTimes = new Array(Math.ceil(columns)).fill(0);
            columnPhases = new Array(Math.ceil(columns)).fill(0).map(() => Math.random() * Math.PI * 2);
            columnVelocities = new Array(Math.ceil(columns)).fill(baseVerticalSpeed);
            columnGaps = new Array(Math.ceil(columns)).fill(fontSize);
            columnDelays = new Array(Math.ceil(columns)).fill(0).map(() => Math.random() * lineVariation);
            columnSpeeds = new Array(Math.ceil(columns)).fill(1); // Initialize column speeds for waterfall
        }

        // Call initialization
        initializeColumns();

        function startAnimation() {
            clearInterval(interval);
            interval = setInterval(draw, speed);
        }

        function draw() {
            if (paused) return;

            const currentTime = Date.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
            lastFrameTime = currentTime;

            // Apply fade effect
            ctx.fillStyle = `rgba(0, 0, 0, ${fadeSpeed})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Handle color cycling if enabled
            if (colorCycleEnabled) {
                if (currentTime - lastColorChange > colorCycleSpeed * 1000) {
                    color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    document.getElementById('colorPicker').value = color;
                    updateMenuButtonColor(color);
                    lastColorChange = currentTime;
                }
            }

            // Set character style
            if (gradientMode && gradientColors) {
                ctx.fillStyle = createGradient(ctx);
            } else {
                ctx.fillStyle = color;
            }

            // Apply glow if enabled
            if (glowEnabled) {
                ctx.shadowBlur = 5;
                ctx.shadowColor = color;
            } else {
                ctx.shadowBlur = 0;
            }

            // Draw characters
            ctx.font = fontSize + 'px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const time = currentTime / 1000; // Time in seconds for movement calculations

            for (let i = 0; i < rainDrops.length; i++) {
                // Calculate base x position with horizontal movement if enabled
                let x = i * fontSize + fontSize / 2;
                if (movementEnabled && horizontalMovement > 0) {
                    x += calculateColumnMovement(i, time, horizontalMovement);
                }

                if (waterfallEnabled) {
                    // Waterfall mode logic
                    const y = rainDrops[i] * fontSize;
                    
                    // Calculate speed based on intensity
                    const baseSpeed = 1;
                    const intensityFactor = waterfallIntensity / 100;
                    
                    let speed = baseSpeed;
                    const time = Date.now() * 0.001; // Current time in seconds
                    
                    if (intensityFactor === 0.5) {
                        // At 50%: Perfect uniform speed
                        speed = baseSpeed;
                    } else if (intensityFactor < 0.5) {
                        // Below 50%: Natural variations with increasing randomness
                        const variationStrength = 1 - (intensityFactor * 2); // 1 at 0%, 0 at 50%
                        // Use column index and time for consistent variations
                        const columnPhase = i * 0.1;
                        const timePhase = time * 0.5;
                        speed = baseSpeed * (1 + Math.sin(columnPhase + timePhase) * variationStrength * 0.3);
                    } else {
                        // Above 50%: Wave patterns
                        const patternStrength = (intensityFactor - 0.5) * 2; // 0 at 50%, 1 at 100%
                        const columnPhase = i * 0.2;
                        const timePhase = time * 0.3;
                        
                        // Create a wave pattern that moves through the columns
                        speed = baseSpeed * (1 + Math.sin(columnPhase + timePhase) * patternStrength * 0.5);
                    }

                    // Ensure speed stays within reasonable bounds
                    speed = Math.max(0.7, Math.min(1.3, speed));

                    // Draw character
                    ctx.fillText(rainDropsChars[i], x, y);

                    // Update position
                    rainDrops[i] += speed;

                    // Reset when character reaches bottom
                    if (y > canvas.height) {
                        // Reset position
                        rainDrops[i] = intensityFactor === 0.5 ? 0 : Math.random() * -1;
                        
                        // Update character
                        if (sequenceEnabled) {
                            const selectedCharsArray = Array.from(selectedChars);
                            switch (sequenceMode) {
                                case 'random':
                                    rainDropsChars[i] = selectedCharsArray[Math.floor(Math.random() * selectedCharsArray.length)];
                                    break;
                                case 'orderly':
                                    const position = Math.floor(i / trailLength);
                                    rainDropsChars[i] = selectedCharsArray[position % selectedCharsArray.length];
                                    break;
                                case 'sequential':
                                    if (customSequence) {
                                        const position = Math.floor(i / trailLength);
                                        rainDropsChars[i] = customSequence[position % customSequence.length];
                                    }
                                    break;
                            }
                        } else {
                            rainDropsChars[i] = getRandomSelectedChar();
                        }
                    }
                } else if (!movementEnabled || precipitationMode === 'continuous') {
                    // Normal continuous rain behavior
                    const y = rainDrops[i] * fontSize;

                    if (sequenceEnabled) {
                        if (y > canvas.height && Math.random() > 0.975) {
                            rainDrops[i] = 0;
                            updateSequenceCharacters();
                        }
                    } else {
                        const currentLine = Math.floor(y / fontSize);
                        if (currentLine > 0 && currentLine % lineChangeRate === 0 && 
                            Math.floor((y - fontSize) / fontSize) !== currentLine) {
                            rainDropsChars[i] = getRandomSelectedChar();
                        }
                        
                        if (y > canvas.height && Math.random() > 0.975) {
                            rainDrops[i] = 0;
                        }
                    }

                    // Apply alpha trail effect
                    const alpha = Math.min(1, (canvas.height - y) / (canvas.height * 0.3));
                    ctx.globalAlpha = alpha;
                    ctx.fillText(rainDropsChars[i], x, y - fontSize / 2);
                    ctx.globalAlpha = 1;
                    
                    rainDrops[i] += adjustDensity(1, 'continuous');
                } else if (precipitationMode === 'dense') {
                    // Dense packed rain behavior
                    const y = rainDrops[i] * fontSize;

                    // Apply line variation delay
                    const delay = columnDelays[i];
                    if (y < delay) continue;

                    // Check for gap with previous character
                    const prevY = i > 0 ? rainDrops[i-1] * fontSize : -fontSize;
                    const gap = y - prevY;
                    
                    // Adjust velocity based on gap and dense pack setting
                    const targetGap = fontSize * (densePack / 10);
                    if (gap < targetGap) {
                        columnVelocities[i] *= 0.95; // Slow down if too close
                    } else if (gap > targetGap * 2) {
                        columnVelocities[i] *= 1.05; // Speed up if too far
                    }
                    
                    // Keep velocity within bounds
                    columnVelocities[i] = Math.max(baseVerticalSpeed * 0.5, 
                                                 Math.min(baseVerticalSpeed * 1.5, columnVelocities[i]));

                    // Draw trail characters with fading effect
                    for (let t = 0; t < trailChars; t++) {
                        const trailY = y - (t * fontSize * (densePack / 10));
                        if (trailY > 0) {
                            const alpha = 1 - (t / trailChars);
                            ctx.globalAlpha = alpha;
                            ctx.fillText(getRandomSelectedChar(), x, trailY - fontSize / 2);
                        }
                    }
                    ctx.globalAlpha = 1;
                    ctx.fillText(rainDropsChars[i], x, y - fontSize / 2);

                    if (y > canvas.height) {
                        rainDrops[i] = 0;
                        rainDropsChars[i] = getRandomSelectedChar();
                        columnVelocities[i] = baseVerticalSpeed;
                        // Add random variation to starting position for natural look
                        rainDrops[i] = Math.random() * -3; // Random start height above screen
                        columnDelays[i] = Math.random() * lineVariation;
                    }
                    
                    rainDrops[i] += (columnVelocities[i] * deltaTime) / fontSize;
                } else if (precipitationMode === 'individual') {
                    // Individual rain lines with spacing
                    const y = rainDrops[i] * fontSize;

                    // Dynamic line variation - changes as lines fall
                    const time = currentTime / 1000; // Time in seconds
                    const variationSpeed = 0.2; // Slower speed for smoother variation
                    const variationPhase = columnPhases[i]; // Use existing phase for consistency
                    
                    // Calculate dynamic variation using multiple sine waves for more natural movement
                    const primaryWave = Math.sin(time * variationSpeed + variationPhase);
                    const secondaryWave = Math.sin(time * variationSpeed * 0.5 + variationPhase * 2) * 0.5;
                    const dynamicVariation = (primaryWave + secondaryWave) * lineVariation;
                    
                    // Scale variation based on screen height for longer-lasting effect
                    const variationScale = canvas.height / 2;
                    const variationOffset = (dynamicVariation / 100) * variationScale;
                    const adjustedY = y + variationOffset;

                    // Change characters based on position
                    const currentLine = Math.floor(adjustedY / fontSize);
                    if (currentLine > 0 && currentLine % lineChangeRate === 0 && 
                        Math.floor((adjustedY - fontSize) / fontSize) !== currentLine) {
                        rainDropsChars[i] = getRandomSelectedChar();
                    }

                    if (adjustedY > -fontSize && adjustedY < canvas.height + fontSize) {
                        // Improved fade effect - starts fading from middle of screen
                        const fadeStart = canvas.height * 0.5; // Start fading halfway down
                        const fadeLength = canvas.height * 0.5; // Fade over the remaining height
                        let alpha = 1;
                        
                        if (adjustedY > fadeStart) {
                            alpha = Math.max(0.1, 1 - ((adjustedY - fadeStart) / fadeLength));
                        }
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillText(rainDropsChars[i], x, adjustedY - fontSize / 2);
                        ctx.globalAlpha = 1;
                    }

                    const spacing = adjustDensity(fontSize * lineSpacing, 'individual');
                    if (y > canvas.height + spacing) {
                        rainDrops[i] = 0;
                        lastSpawnTimes[i] = currentTime;
                        rainDropsChars[i] = getRandomSelectedChar();
                        // Update phase for next cycle with slight randomization
                        columnPhases[i] = (columnPhases[i] + Math.random() * Math.PI) % (Math.PI * 2);
                    }
                    
                    // All lines move together
                    rainDrops[i] += 1;

                    // Start new cycle when all lines have finished
                    if (i === rainDrops.length - 1 && y > canvas.height + spacing) {
                        // Reset all lines to start together with new random phases
                        for (let j = 0; j < rainDrops.length; j++) {
                            rainDrops[j] = 0;
                            lastSpawnTimes[j] = currentTime;
                            rainDropsChars[j] = getRandomSelectedChar();
                            // Give each column a new random phase with some relation to neighbors
                            const neighborPhase = j > 0 ? columnPhases[j-1] : Math.random() * Math.PI * 2;
                            columnPhases[j] = (neighborPhase + Math.random() * Math.PI * 0.5) % (Math.PI * 2);
                        }
                    }
                } else if (precipitationMode === 'single') {
                    // Single line per cycle mode
                    if (i === currentColumn) {
                        const y = rainDrops[i] * fontSize;
                        ctx.fillText(rainDropsChars[i], x, y - fontSize / 2);

                        if (y > canvas.height) {
                            rainDrops[i] = 0;
                            rainDropsChars[i] = getRandomSelectedChar();
                            currentColumn = (currentColumn + 1) % rainDrops.length;
                            lastSpawnTimes[currentColumn] = currentTime;
                        }
                        
                        rainDrops[i] += adjustDensity(1, 'single');
                    }
                }
            }
            
            // Draw additional effects
            if (gridEnabled) drawGrid();
            if (lightingEnabled) drawLighting();
            if (particlesEnabled) drawParticles();
        }

        function drawGrid() {
            // Clear the grid canvas
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            // Set grid line style with custom color and opacity
            const rgb = hexToRgb(gridColor);
            
            // Draw cell backgrounds first
            gridCtx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${gridOpacity * 0.05})`;
            const columns = Math.ceil(gridCanvas.width / fontSize);
            const rows = Math.ceil(gridCanvas.height / fontSize);
            
            for (let col = 0; col < columns; col++) {
                for (let row = 0; row < rows; row++) {
                    const x = col * fontSize;
                    const y = row * fontSize;
                    gridCtx.fillRect(x, y, fontSize, fontSize);
                }
            }

            // Draw grid lines
            gridCtx.beginPath();
            gridCtx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${gridOpacity})`;
            gridCtx.lineWidth = 1;

            // Draw vertical lines
            for (let col = 0; col <= columns; col++) {
                const x = col * fontSize;
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
            }

            // Draw horizontal lines
            for (let row = 0; row <= rows; row++) {
                const y = row * fontSize;
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
            }

            gridCtx.stroke();
        }

        function hexToRgb(hex) {
            // Remove the # if present
            hex = hex.replace(/^#/, '');
            
            // Parse the hex values
            const bigint = parseInt(hex, 16);
            return {
                r: (bigint >> 16) & 255,
                g: (bigint >> 8) & 255,
                b: bigint & 255
            };
        }

        function drawLighting() {
            if (!lightingEnabled) return;

            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.width / 2
            );

            const rgb = hexToRgb(lightingColor);
            gradient.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawParticles() {
            if (!particlesEnabled) return;

            // Update existing particles
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                p.alpha = p.life / PARTICLE_LIFETIME;

                const rgb = hexToRgb(particleColor);
                ctx.fillStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${p.alpha})`;
                ctx.fillRect(p.x, p.y, 2, 2);

                return p.life > 0;
            });

            // Add new particles occasionally
            if (Math.random() < 0.1) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    life: PARTICLE_LIFETIME,
                    alpha: 1
                });
            }
        }

        function createGradient(context) {
            const gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
            if (gradientMode && gradientColors) {
                gradientColors.forEach((color, index) => {
                    gradient.addColorStop(index / (gradientColors.length - 1), color);
                });
            } else {
                gradient.addColorStop(0, color);
                gradient.addColorStop(1, color);
            }
            return gradient;
        }

        function toggleGradient(checked) {
            gradientMode = checked;
            if (checked && !gradientColors) {
                const presetSelect = document.getElementById('gradientPresetSelect');
                updateGradientPreset(presetSelect.value);
            }
        }

        function updateGradientPreset(value) {
            const presets = {
                custom: [color, '#00ff88', color],
                cyber: ['#ff00ff', '#00ffff', '#ff4500'],
                neon: ['#ff073a', '#4dff03', '#03f7ff'],
                matrix2: ['#0f0', '#00ff88', '#00ff00']
            };
            gradientColors = presets[value];
            
            // If gradient mode is enabled, force a redraw
            if (gradientMode) {
                ctx.fillStyle = createGradient(ctx);
            }
        }

        function updateTheme(value) {
            switch(value) {
                case 'matrix':
                    color = '#0f0';
                    break;
                case 'cyberpunk':
                    color = '#ff00ff';
                    break;
                case 'neon':
                    color = '#00ffff';
                    break;
                case 'monochrome':
                    color = '#ffffff';
                    break;
            }
            document.getElementById('colorPicker').value = color;
            updateMenuButtonColor(color);
            
            // Update gradient if in gradient mode
            if (gradientMode && document.getElementById('gradientPresetSelect').value === 'custom') {
                updateGradientPreset('custom');
            }
        }

        function updateGridColor(newColor) {
            gridColor = newColor;
            if (gridEnabled) {
                drawGrid();
            }
        }

        function updateGridOpacity(newOpacity) {
            gridOpacity = parseFloat(newOpacity);
            if (gridEnabled) {
                drawGrid();
            }
        }

        // Start animation
        startAnimation();

        function resizeCanvases() {
            canvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            gridCanvas.height = window.innerHeight;
            gridCanvas.width = window.innerWidth;
            columns = canvas.width / fontSize;
            rainDrops = Array(Math.ceil(columns)).fill(1);
            rainDropsChars = Array(Math.ceil(columns)).fill().map(() => 
                alphabet.charAt(Math.floor(Math.random() * alphabet.length))
            );
            if (gridEnabled) {
                drawGrid();
            }
        }

        // Initial canvas setup
        resizeCanvases();

        function togglePause() {
            paused = !paused;
        }

        function randomizeColor() {
            color = `#${Math.floor(Math.random()*16777215).toString(16)}`;
            document.getElementById('colorPicker').value = color;
            updateMenuButtonColor(color);
        }

        function updateColor(newColor) {
            color = newColor;
            updateMenuButtonColor(newColor);
        }

        function updateMenuButtonColor(newColor) {
            document.getElementById('toggleToolbar').style.backgroundColor = newColor;
            document.getElementById('toggleToolbar').style.color = getContrastColor(newColor);
        }

        function getContrastColor(hexcolor) {
            let r = parseInt(hexcolor.substr(1,2),16);
            let g = parseInt(hexcolor.substr(3,2),16);
            let b = parseInt(hexcolor.substr(5,2),16);
            let yiq = ((r*299)+(g*587)+(b*114))/1000;
            return (yiq >= 128) ? 'black' : 'white';
        }

        function updateSpeed(newSpeed) {
            speed = parseInt(newSpeed);
            startAnimation();
        }

        function updateFontSize(newSize) {
            fontSize = parseInt(newSize);
            columns = canvas.width / fontSize;
            rainDrops = Array(Math.ceil(columns)).fill(1);
            rainDropsChars = Array(Math.ceil(columns)).fill().map(() => alphabet.charAt(Math.floor(Math.random() * alphabet.length)));
        }

        function updateFadeSpeed(newSpeed) {
            fadeSpeed = parseFloat(newSpeed);
        }

        function updateCharacterSet(set) {
            const customControls = document.getElementById('customCharSetControls');
            
            switch(set) {
                case 'binary':
                    alphabet = '01';
                    customControls.style.display = 'none';
                    break;
                case 'ascii':
                    alphabet = '';
                    for (let i = 33; i <= 126; i++) {
                        alphabet += String.fromCharCode(i);
                    }
                    customControls.style.display = 'none';
                    break;
                case 'custom':
                    customControls.style.display = 'block';
                    const customInput = document.getElementById('customCharInput');
                    if (customInput.value) {
                        alphabet = customInput.value;
                    } else {
                        customInput.value = alphabet;
                    }
                    break;
                default: // matrix
                    alphabet = katakana + latin + nums;
                    customControls.style.display = 'none';
            }
            
            // Reset character selection
            selectedChars = new Set(alphabet.split(''));
            updateCharacterSelector();
            updateCharacterChangeIntervalState();
            
            // Refresh all characters
            rainDropsChars = rainDropsChars.map(() => 
                getRandomSelectedChar()
            );
        }

        function updateCustomCharSet(value) {
            if (value.length > 0) {
                alphabet = value;
                // Reset character selection
                selectedChars = new Set(alphabet.split(''));
                updateCharacterSelector();
                updateCharacterChangeIntervalState();
                
                // Refresh all characters
                rainDropsChars = rainDropsChars.map(() => 
                    getRandomSelectedChar()
                );
            }
        }

        function toggleCharacterSelector(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const selector = document.getElementById('characterSelector');
            const btn = document.getElementById('charSelectorBtn');
            
            if (!selector.classList.contains('visible')) {
                // Close any other open selectors first
                document.querySelectorAll('.character-selector.visible').forEach(sel => {
                    if (sel !== selector) {
                        sel.classList.remove('visible');
                    }
                });
                
                selector.classList.add('visible');
                btn.classList.add('active');
                
                // Position the selector
                const btnRect = btn.getBoundingClientRect();
                const selectorHeight = selector.offsetHeight;
                const windowHeight = window.innerHeight;
                
                // Check if there's room below the button
                if (btnRect.bottom + selectorHeight > windowHeight) {
                    // Position above the button if not enough space below
                    selector.style.top = 'auto';
                    selector.style.bottom = '100%';
                    selector.style.marginTop = '0';
                    selector.style.marginBottom = '5px';
                } else {
                    // Position below the button
                    selector.style.top = '100%';
                    selector.style.bottom = 'auto';
                    selector.style.marginTop = '5px';
                    selector.style.marginBottom = '0';
                }
                
                // Add click outside listener
                setTimeout(() => {
                    document.addEventListener('click', closeCharacterSelector);
                }, 0);
            } else {
                closeCharacterSelector();
            }
        }

        function closeCharacterSelector(event) {
            const selector = document.getElementById('characterSelector');
            const btn = document.getElementById('charSelectorBtn');
            const container = document.querySelector('.character-selector-container');
            
            if (event) {
                const isClickInside = container.contains(event.target);
                if (isClickInside && event.target !== btn) return;
            }
            
            selector.classList.remove('visible');
            btn.classList.remove('active');
            document.removeEventListener('click', closeCharacterSelector);
        }

        function updateCharacterSelector() {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            
            alphabet.split('').forEach(char => {
                const box = document.createElement('div');
                box.className = `char-box ${selectedChars.has(char) ? 'selected' : ''}`;
                box.textContent = char;
                box.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (selectedChars.has(char)) {
                        if (selectedChars.size > 1) {
                            selectedChars.delete(char);
                        }
                    } else {
                        selectedChars.add(char);
                    }
                    updateCharacterSelector();
                    updateCharacterChangeIntervalState();
                };
                grid.appendChild(box);
            });
        }

        function selectAllCharacters() {
            selectedChars = new Set(alphabet.split(''));
            updateCharacterSelector();
            updateCharacterChangeIntervalState();
        }

        function deselectAllCharacters() {
            const firstChar = alphabet[0];
            selectedChars = new Set([firstChar]);
            updateCharacterSelector();
            updateCharacterChangeIntervalState();
        }

        function updateCharacterChangeIntervalState() {
            const lineChangeControls = document.querySelector('label[style*="display: flex"]');
            const isSingleChar = selectedChars.size === 1;
            
            if (isSingleChar) {
                lineChangeControls.style.opacity = '0.5';
                lineChangeControls.style.pointerEvents = 'none';
                document.getElementById('lineChangeSlider').disabled = true;
                document.getElementById('minLineChange').disabled = true;
                document.getElementById('maxLineChange').disabled = true;
            } else {
                lineChangeControls.style.opacity = '1';
                lineChangeControls.style.pointerEvents = 'auto';
                document.getElementById('lineChangeSlider').disabled = false;
                document.getElementById('minLineChange').disabled = false;
                document.getElementById('maxLineChange').disabled = false;
            }
        }

        function getRandomSelectedChar() {
            const chars = Array.from(selectedChars);
            return chars[Math.floor(Math.random() * chars.length)];
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function toggleToolbar() {
            document.getElementById('toolbar').classList.toggle('hidden');
        }

        function updateLineChangeRange() {
            const min = parseInt(document.getElementById('minLineChange').value);
            const max = parseInt(document.getElementById('maxLineChange').value);
            const current = parseInt(document.getElementById('lineChangeSlider').value);
            
            // Ensure min <= max
            if (min > max) {
                document.getElementById('maxLineChange').value = min;
                maxLineChange = min;
            } else {
                minLineChange = min;
                maxLineChange = max;
            }

            // Update slider range and adjust its visual width based on range
            const slider = document.getElementById('lineChangeSlider');
            slider.min = minLineChange;
            slider.max = maxLineChange;
            
            // Adjust slider width based on range
            const range = maxLineChange - minLineChange;
            const baseWidth = 150; // Base width in pixels
            const width = Math.max(baseWidth, range * 30); // 30 pixels per unit
            slider.style.width = `${width}px`;
            
            // Keep current value within new range
            if (current < min) {
                slider.value = min;
                updateLineChangeRate(min);
            } else if (current > max) {
                slider.value = max;
                updateLineChangeRate(max);
            }
        }

        function updateLineChangeRate(newRate) {
            lineChangeRate = parseInt(newRate);
            // Ensure rate stays within min/max bounds
            if (lineChangeRate < minLineChange) lineChangeRate = minLineChange;
            if (lineChangeRate > maxLineChange) lineChangeRate = maxLineChange;
            document.getElementById('lineChangeSlider').value = lineChangeRate;
        }

        function resetToDefaults() {
            color = '#00f';
            speed = 50;
            fontSize = 16;
            fadeSpeed = 0.05;
            lineChangeRate = 1;
            minLineChange = 1;
            maxLineChange = 4;
            alphabet = katakana + latin + nums;

            document.getElementById('colorPicker').value = color;
            document.getElementById('speedSlider').value = speed;
            document.getElementById('fontSizeSlider').value = fontSize;
            document.getElementById('fadeSpeedSlider').value = fadeSpeed;
            document.getElementById('lineChangeSlider').value = lineChangeRate;
            document.getElementById('minLineChange').value = minLineChange;
            document.getElementById('maxLineChange').value = maxLineChange;
            document.getElementById('charSetSelect').value = 'matrix';

            updateColor(color);
            updateSpeed(speed);
            updateFontSize(fontSize);
            updateFadeSpeed(fadeSpeed);
            updateLineChangeRate(lineChangeRate);
            updateLineChangeRange();

            columns = canvas.width / fontSize;
            rainDrops = Array(Math.ceil(columns)).fill(1);
            rainDropsChars = Array(Math.ceil(columns)).fill().map(() => 
                alphabet.charAt(Math.floor(Math.random() * alphabet.length))
            );
            selectedChars = new Set(alphabet.split('')); // Reset character selection
            updateCharacterSelector();
            updateCharacterChangeIntervalState();

            gradientMode = false;
            glowEnabled = false;
            gridEnabled = false;
            particlesEnabled = false;
            lightingEnabled = false;
            gradientColors = null;

            // Reset checkboxes
            document.getElementById('gradientCheckbox').checked = false;
            document.getElementById('glowCheckbox').checked = false;
            document.getElementById('gridCheckbox').checked = false;
            document.getElementById('particleCheckbox').checked = false;
            document.getElementById('lightingCheckbox').checked = false;
            document.getElementById('themeSelect').value = 'matrix';
            document.getElementById('gradientPresetSelect').value = 'custom';

            gridColor = '#00ff00';
            gridOpacity = 0.15;
            document.getElementById('gridColorPicker').value = gridColor;
            document.getElementById('gridOpacitySlider').value = gridOpacity;

            particleColor = '#00ff00';
            lightingColor = '#00ff00';
            document.getElementById('particleColorPicker').value = particleColor;
            document.getElementById('lightingColorPicker').value = lightingColor;

            document.getElementById('customCharInput').value = '';
            document.getElementById('customCharSetControls').style.display = 'none';

            sequenceEnabled = false;
            sequenceMode = 'random';
            customSequence = '';
            trailLength = 3;
            colorCycleSpeed = 2;
            colorCycleEnabled = false;
            currentSequenceIndex = 0;
            
            document.getElementById('sequenceCheckbox').checked = false;
            document.getElementById('sequenceControls').style.display = 'none';
            document.getElementById('sequenceModeSelect').value = 'random';
            document.getElementById('customSequenceInput').value = '';
            document.getElementById('trailLengthSlider').value = trailLength;
            document.getElementById('trailLengthValue').textContent = trailLength;
            document.getElementById('colorSpeedSlider').value = colorCycleSpeed;
            document.getElementById('colorSpeedValue').textContent = colorCycleSpeed;
            document.getElementById('colorCycleCheckbox').checked = false;
            document.getElementById('colorCycleControls').style.display = 'none';

            movementEnabled = false;
            horizontalMovement = 0;
            precipitationMode = 'continuous';
            spawnDelay = 500;
            lineSpacing = 4;
            currentColumn = 0;
            
            document.getElementById('movementCheckbox').checked = false;
            document.getElementById('movementControls').style.display = 'none';
            document.getElementById('horizontalMovementSlider').value = horizontalMovement;
            document.getElementById('horizontalMovementValue').textContent = horizontalMovement;
            document.getElementById('precipitationSelect').value = precipitationMode;
            document.getElementById('spawnDelaySlider').value = spawnDelay;
            document.getElementById('spawnDelayValue').textContent = '0.5s';
            document.getElementById('lineSpacingSlider').value = lineSpacing;
            document.getElementById('lineSpacingValue').textContent = lineSpacing;
            
            density = 5;
            document.getElementById('densitySlider').value = density;
            document.getElementById('densityValue').textContent = density;
            
            // Reset velocities and gaps
            columnVelocities = new Array(Math.ceil(columns)).fill(baseVerticalSpeed);
            columnGaps = new Array(Math.ceil(columns)).fill(fontSize);
            
            movementRange = 15;
            document.getElementById('movementRangeInput').value = movementRange;
            
            densePack = 3;
            trailChars = 3;
            lineVariation = 30;
            
            document.getElementById('densePackSlider').value = densePack;
            document.getElementById('densePackValue').textContent = densePack;
            document.getElementById('trailCharSlider').value = trailChars;
            document.getElementById('trailCharValue').textContent = trailChars;
            document.getElementById('lineVariationSlider').value = lineVariation;
            document.getElementById('lineVariationValue').textContent = lineVariation + '%';
            
            initializeColumns();
        }

        // Initialize menu button color
        updateMenuButtonColor(color);

        // Initialize character selector
        updateCharacterSet('matrix');

        // Call updateLineChangeRange initially to set proper width
        window.addEventListener('load', () => {
            updateLineChangeRange();
        });

        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const content = section.querySelector('.section-content');
            const arrow = section.querySelector('.section-arrow');
            
            // Close all other sections first
            document.querySelectorAll('.section-content').forEach(otherContent => {
                if (otherContent !== content && otherContent.classList.contains('visible')) {
                    otherContent.classList.remove('visible');
                    const otherArrow = otherContent.parentElement.querySelector('.section-arrow');
                    if (otherArrow) {
                        otherArrow.textContent = '▶';
                    }
                }
            });
            
            // Toggle current section
            content.classList.toggle('visible');
            arrow.textContent = content.classList.contains('visible') ? '▼' : '▶';
            
            // Close character selector when section is closed
            if (!content.classList.contains('visible')) {
                closeCharacterSelector();
            }
        }

        // Initialize sections
        document.addEventListener('DOMContentLoaded', () => {
            // Show the first section by default
            const firstSection = document.querySelector('.section');
            if (firstSection) {
                const content = firstSection.querySelector('.section-content');
                const arrow = firstSection.querySelector('.section-arrow');
                content.classList.add('visible');
                if (arrow) {
                    arrow.textContent = '▼';
                }
            }
            
            // Initialize all other sections as collapsed
            document.querySelectorAll('.section:not(:first-child)').forEach(section => {
                const arrow = section.querySelector('.section-arrow');
                if (arrow) {
                    arrow.textContent = '▶';
                }
            });
        });

        function toggleGlow(checked) {
            glowEnabled = checked;
            if (glowEnabled) {
                ctx.shadowBlur = 5;
                ctx.shadowColor = color;
            } else {
                ctx.shadowBlur = 0;
            }
        }

        function toggleGrid(checked) {
            gridEnabled = checked;
            const gridControls = document.getElementById('gridControls');
            gridControls.style.display = checked ? 'block' : 'none';
            gridCanvas.style.display = checked ? 'block' : 'none';
            
            if (checked) {
                document.getElementById('gridColorPicker').value = gridColor;
                document.getElementById('gridOpacitySlider').value = gridOpacity;
                drawGrid();
            }
        }

        function toggleParticles(checked) {
            particlesEnabled = checked;
            const particleControls = document.getElementById('particleControls');
            particleControls.style.display = checked ? 'block' : 'none';
            
            if (checked) {
                document.getElementById('particleColorPicker').value = particleColor;
                particles = [];
            }
        }

        function toggleLighting(checked) {
            lightingEnabled = checked;
            const lightingControls = document.getElementById('lightingControls');
            lightingControls.style.display = checked ? 'block' : 'none';
            
            if (checked) {
                document.getElementById('lightingColorPicker').value = lightingColor;
            }
        }

        function updateParticleColor(newColor) {
            particleColor = newColor;
        }

        function updateLightingColor(newColor) {
            lightingColor = newColor;
        }

        function saveSettings() {
            const settings = {
                // Basic settings
                color: color,
                speed: speed,
                fontSize: fontSize,
                fadeSpeed: fadeSpeed,
                lineChangeRate: lineChangeRate,
                minLineChange: minLineChange,
                maxLineChange: maxLineChange,
                alphabet: alphabet,
                selectedChars: Array.from(selectedChars),
                
                // Effect toggles
                gradientMode: gradientMode,
                glowEnabled: glowEnabled,
                gridEnabled: gridEnabled,
                particlesEnabled: particlesEnabled,
                lightingEnabled: lightingEnabled,
                
                // Effect colors and properties
                gradientColors: gradientColors,
                gridColor: gridColor,
                gridOpacity: gridOpacity,
                particleColor: particleColor,
                lightingColor: lightingColor,
                
                // UI states
                customCharacters: document.getElementById('customCharInput').value,
                charSetType: document.getElementById('charSetSelect').value,
                themeType: document.getElementById('themeSelect').value,
                gradientPreset: document.getElementById('gradientPresetSelect').value,
                sequenceEnabled: sequenceEnabled,
                sequenceMode: sequenceMode,
                customSequence: customSequence,
                trailLength: trailLength,
                colorCycleSpeed: colorCycleSpeed,
                colorCycleEnabled: colorCycleEnabled,
                movementEnabled: movementEnabled,
                horizontalMovement: horizontalMovement,
                precipitationMode: precipitationMode,
                spawnDelay: spawnDelay,
                lineSpacing: lineSpacing,
                density: density,
                movementRange: movementRange,
                densePack: densePack,
                trailChars: trailChars,
                lineVariation: lineVariation
            };

            try {
                const blob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'matrix-settings.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error saving settings:', error);
                alert('Error saving settings. Please try again.');
            }
        }

        function loadSettings() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const settings = JSON.parse(event.target.result);
                        console.log('Loading settings:', settings);
                        applySettings(settings);
                    } catch (error) {
                        console.error('Error parsing settings file:', error);
                        alert('Error loading settings file. Please ensure it is a valid JSON file.');
                    }
                };
                reader.onerror = (error) => {
                    console.error('Error reading file:', error);
                    alert('Error reading the settings file. Please try again.');
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function applySettings(settings) {
            try {
                // First, ensure all sections are properly initialized
                document.querySelectorAll('.section').forEach(section => {
                    const content = section.querySelector('.section-content');
                    const arrow = section.querySelector('.section-arrow');
                    if (content) content.classList.remove('visible');
                    if (arrow) arrow.textContent = '▶';
                });

                // Show the first section by default
                const firstSection = document.querySelector('.section');
                if (firstSection) {
                    const content = firstSection.querySelector('.section-content');
                    const arrow = firstSection.querySelector('.section-arrow');
                    if (content) content.classList.add('visible');
                    if (arrow) arrow.textContent = '▼';
                }

                // Apply basic settings with validation
                if (settings.color) color = settings.color;
                if (settings.speed) speed = parseInt(settings.speed);
                if (settings.fontSize) fontSize = parseInt(settings.fontSize);
                if (settings.fadeSpeed) fadeSpeed = parseFloat(settings.fadeSpeed);
                if (settings.lineChangeRate) lineChangeRate = parseInt(settings.lineChangeRate);
                if (settings.minLineChange) minLineChange = parseInt(settings.minLineChange);
                if (settings.maxLineChange) maxLineChange = parseInt(settings.maxLineChange);
                if (settings.alphabet) alphabet = settings.alphabet;
                if (settings.selectedChars) selectedChars = new Set(settings.selectedChars);

                // Apply effect settings
                gradientMode = Boolean(settings.gradientMode);
                glowEnabled = Boolean(settings.glowEnabled);
                gridEnabled = Boolean(settings.gridEnabled);
                particlesEnabled = Boolean(settings.particlesEnabled);
                lightingEnabled = Boolean(settings.lightingEnabled);

                // Apply effect colors and properties
                if (settings.gradientColors) gradientColors = settings.gradientColors;
                if (settings.gridColor) gridColor = settings.gridColor;
                if (settings.gridOpacity) gridOpacity = parseFloat(settings.gridOpacity);
                if (settings.particleColor) particleColor = settings.particleColor;
                if (settings.lightingColor) lightingColor = settings.lightingColor;

                // Update UI elements - with null checks
                const elements = {
                    colorPicker: document.getElementById('colorPicker'),
                    speedSlider: document.getElementById('speedSlider'),
                    fontSizeSlider: document.getElementById('fontSizeSlider'),
                    fadeSpeedSlider: document.getElementById('fadeSpeedSlider'),
                    lineChangeSlider: document.getElementById('lineChangeSlider'),
                    minLineChange: document.getElementById('minLineChange'),
                    maxLineChange: document.getElementById('maxLineChange'),
                    gradientCheckbox: document.getElementById('gradientCheckbox'),
                    glowCheckbox: document.getElementById('glowCheckbox'),
                    gridCheckbox: document.getElementById('gridCheckbox'),
                    gridControls: document.getElementById('gridControls'),
                    gridColorPicker: document.getElementById('gridColorPicker'),
                    gridOpacitySlider: document.getElementById('gridOpacitySlider'),
                    particleCheckbox: document.getElementById('particleCheckbox'),
                    particleControls: document.getElementById('particleControls'),
                    particleColorPicker: document.getElementById('particleColorPicker'),
                    lightingCheckbox: document.getElementById('lightingCheckbox'),
                    lightingControls: document.getElementById('lightingControls'),
                    lightingColorPicker: document.getElementById('lightingColorPicker'),
                    charSetSelect: document.getElementById('charSetSelect'),
                    customControls: document.getElementById('customCharSetControls'),
                    customCharInput: document.getElementById('customCharInput'),
                    themeSelect: document.getElementById('themeSelect'),
                    gradientPresetSelect: document.getElementById('gradientPresetSelect'),
                    toolbar: document.getElementById('toolbar')
                };

                // Update UI elements safely
                if (elements.colorPicker) elements.colorPicker.value = color;
                if (elements.speedSlider) elements.speedSlider.value = speed;
                if (elements.fontSizeSlider) elements.fontSizeSlider.value = fontSize;
                if (elements.fadeSpeedSlider) elements.fadeSpeedSlider.value = fadeSpeed;
                if (elements.lineChangeSlider) elements.lineChangeSlider.value = lineChangeRate;
                if (elements.minLineChange) elements.minLineChange.value = minLineChange;
                if (elements.maxLineChange) elements.maxLineChange.value = maxLineChange;

                // Update effect toggles and their controls safely
                if (elements.gradientCheckbox) elements.gradientCheckbox.checked = gradientMode;
                if (elements.glowCheckbox) elements.glowCheckbox.checked = glowEnabled;
                
                // Update grid controls safely
                if (elements.gridCheckbox) elements.gridCheckbox.checked = gridEnabled;
                if (elements.gridControls) elements.gridControls.style.display = gridEnabled ? 'block' : 'none';
                if (elements.gridColorPicker) elements.gridColorPicker.value = gridColor;
                if (elements.gridOpacitySlider) elements.gridOpacitySlider.value = gridOpacity;
                if (gridCanvas) gridCanvas.style.display = gridEnabled ? 'block' : 'none';
                
                // Update particle controls safely
                if (elements.particleCheckbox) elements.particleCheckbox.checked = particlesEnabled;
                if (elements.particleControls) elements.particleControls.style.display = particlesEnabled ? 'block' : 'none';
                if (elements.particleColorPicker) elements.particleColorPicker.value = particleColor;
                
                // Update lighting controls safely
                if (elements.lightingCheckbox) elements.lightingCheckbox.checked = lightingEnabled;
                if (elements.lightingControls) elements.lightingControls.style.display = lightingEnabled ? 'block' : 'none';
                if (elements.lightingColorPicker) elements.lightingColorPicker.value = lightingColor;

                // Update dropdowns and custom input safely
                if (elements.charSetSelect) elements.charSetSelect.value = settings.charSetType || 'matrix';
                if (elements.customControls) elements.customControls.style.display = settings.charSetType === 'custom' ? 'block' : 'none';
                if (elements.customCharInput && settings.customCharacters) elements.customCharInput.value = settings.customCharacters;
                if (elements.themeSelect) elements.themeSelect.value = settings.themeType || 'matrix';
                if (elements.gradientPresetSelect) elements.gradientPresetSelect.value = settings.gradientPreset || 'custom';

                // Apply all changes
                updateCharacterSet(settings.charSetType || 'matrix');
                updateTheme(settings.themeType || 'matrix');
                updateSpeed(speed);
                updateFontSize(fontSize);
                updateFadeSpeed(fadeSpeed);
                updateLineChangeRate(lineChangeRate);
                updateLineChangeRange();
                updateMenuButtonColor(color);

                // Refresh the matrix
                columns = canvas.width / fontSize;
                rainDrops = Array(Math.ceil(columns)).fill(1);
                rainDropsChars = Array(Math.ceil(columns)).fill().map(() => getRandomSelectedChar());

                // Redraw grid if enabled
                if (gridEnabled) {
                    drawGrid();
                }

                // Make sure the toolbar is visible
                if (elements.toolbar) elements.toolbar.classList.remove('hidden');

                // Apply sequence settings
                if (settings.hasOwnProperty('sequenceEnabled')) {
                    sequenceEnabled = settings.sequenceEnabled;
                    document.getElementById('sequenceCheckbox').checked = sequenceEnabled;
                    document.getElementById('sequenceControls').style.display = sequenceEnabled ? 'block' : 'none';
                }
                
                if (settings.hasOwnProperty('sequenceMode')) {
                    sequenceMode = settings.sequenceMode;
                    document.getElementById('sequenceModeSelect').value = sequenceMode;
                    document.getElementById('sequentialControls').style.display = 
                        sequenceEnabled ? (sequenceMode === 'sequential' ? 'block' : 'none') : 'none';
                }
                
                if (settings.hasOwnProperty('customSequence')) {
                    customSequence = settings.customSequence;
                    document.getElementById('customSequenceInput').value = customSequence;
                }
                
                if (settings.hasOwnProperty('trailLength')) {
                    trailLength = settings.trailLength;
                    document.getElementById('trailLengthSlider').value = trailLength;
                    document.getElementById('trailLengthValue').textContent = trailLength;
                }
                
                if (settings.hasOwnProperty('colorCycleSpeed')) {
                    colorCycleSpeed = settings.colorCycleSpeed;
                    document.getElementById('colorSpeedSlider').value = colorCycleSpeed;
                    document.getElementById('colorSpeedValue').textContent = colorCycleSpeed;
                }
                
                if (settings.hasOwnProperty('colorCycleEnabled')) {
                    colorCycleEnabled = settings.colorCycleEnabled;
                    document.getElementById('colorCycleCheckbox').checked = colorCycleEnabled;
                    document.getElementById('colorCycleControls').style.display = 
                        colorCycleEnabled ? 'block' : 'none';
                }
                
                if (sequenceEnabled) {
                    updateSequenceCharacters();
                }

                // Apply movement settings
                if (settings.hasOwnProperty('movementEnabled')) {
                    movementEnabled = settings.movementEnabled;
                    document.getElementById('movementCheckbox').checked = movementEnabled;
                    document.getElementById('movementControls').style.display = 
                        movementEnabled ? 'block' : 'none';
                }
                
                if (settings.hasOwnProperty('horizontalMovement')) {
                    horizontalMovement = settings.horizontalMovement;
                    document.getElementById('horizontalMovementSlider').value = horizontalMovement;
                    document.getElementById('horizontalMovementValue').textContent = horizontalMovement;
                }
                
                if (settings.hasOwnProperty('precipitationMode')) {
                    precipitationMode = settings.precipitationMode;
                    document.getElementById('precipitationSelect').value = precipitationMode;
                    document.getElementById('precipitationControls').style.display = 
                        precipitationMode !== 'continuous' ? 'block' : 'none';
                }
                
                if (settings.hasOwnProperty('spawnDelay')) {
                    spawnDelay = settings.spawnDelay;
                    document.getElementById('spawnDelaySlider').value = spawnDelay;
                    document.getElementById('spawnDelayValue').textContent = (spawnDelay / 1000).toFixed(1) + 's';
                }
                
                if (settings.hasOwnProperty('lineSpacing')) {
                    lineSpacing = settings.lineSpacing;
                    document.getElementById('lineSpacingSlider').value = lineSpacing;
                    document.getElementById('lineSpacingValue').textContent = lineSpacing;
                }
                
                if (settings.hasOwnProperty('density')) {
                    density = settings.density;
                    document.getElementById('densitySlider').value = density;
                    document.getElementById('densityValue').textContent = density;
                }
                
                if (settings.hasOwnProperty('movementRange')) {
                    movementRange = settings.movementRange;
                    document.getElementById('movementRangeInput').value = movementRange;
                }
                
                if (settings.hasOwnProperty('densePack')) {
                    densePack = settings.densePack;
                    document.getElementById('densePackSlider').value = densePack;
                    document.getElementById('densePackValue').textContent = densePack;
                }
                
                if (settings.hasOwnProperty('trailChars')) {
                    trailChars = settings.trailChars;
                    document.getElementById('trailCharSlider').value = trailChars;
                    document.getElementById('trailCharValue').textContent = trailChars;
                }
                
                if (settings.hasOwnProperty('lineVariation')) {
                    lineVariation = settings.lineVariation;
                    document.getElementById('lineVariationSlider').value = lineVariation;
                    document.getElementById('lineVariationValue').textContent = lineVariation + '%';
                }
                
                initializeColumns();

                console.log('Settings applied successfully');
            } catch (error) {
                console.error('Error applying settings:', error);
                alert(`Error applying settings: ${error.message}`);
            }
        }

        function toggleSequence(enabled) {
            sequenceEnabled = enabled;
            const controls = document.getElementById('sequenceControls');
            const sequentialControls = document.getElementById('sequentialControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (enabled) {
                // Initialize sequence mode
                sequenceMode = document.getElementById('sequenceModeSelect').value;
                if (sequenceMode === 'sequential') {
                    sequentialControls.style.display = 'block';
                }
                updateSequenceCharacters();
            } else {
                // Reset to normal matrix rain
                sequentialControls.style.display = 'none';
                if (!waterfallEnabled) {
                    rainDropsChars = rainDropsChars.map(() => getRandomSelectedChar());
                }
            }
        }

        function updateSequenceMode(value) {
            sequenceMode = value;
            const sequentialControls = document.getElementById('sequentialControls');
            sequentialControls.style.display = value === 'sequential' ? 'block' : 'none';
            
            // Reset sequence index
            currentSequenceIndex = 0;
            
            // Update characters based on new mode
            if (sequenceEnabled) {
                updateSequenceCharacters();
            }
        }

        function updateSequenceCharacters() {
            if (!sequenceEnabled) return;

            switch (sequenceMode) {
                case 'random':
                    rainDropsChars = rainDropsChars.map((_, index) => {
                        return Array.from(selectedChars)[Math.floor(Math.random() * selectedChars.size)];
                    });
                    break;
                    
                case 'orderly':
                    const selectedCharsArray = Array.from(selectedChars);
                    rainDropsChars = rainDropsChars.map((_, index) => {
                        const position = Math.floor(index / trailLength);
                        return selectedCharsArray[position % selectedCharsArray.length];
                    });
                    break;
                    
                case 'sequential':
                    if (customSequence) {
                        rainDropsChars = rainDropsChars.map((_, index) => {
                            const position = Math.floor(index / trailLength);
                            return customSequence[position % customSequence.length];
                        });
                    }
                    break;
            }
        }

        function updateCustomSequence(value) {
            customSequence = value;
            currentSequenceIndex = 0;
            if (sequenceEnabled && sequenceMode === 'sequential') {
                updateSequenceCharacters();
            }
        }

        function updateTrailLength(value) {
            trailLength = parseInt(value);
            document.getElementById('trailLengthValue').textContent = value;
            if (sequenceEnabled) {
                updateSequenceCharacters();
            }
        }

        function updateColorSpeed(value) {
            colorCycleSpeed = parseFloat(value);
            document.getElementById('colorSpeedValue').textContent = value;
        }

        function toggleColorCycle(enabled) {
            colorCycleEnabled = enabled;
            const controls = document.getElementById('colorCycleControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (!enabled) {
                // Reset color to default green when disabling
                color = '#00ff00';
                document.getElementById('colorPicker').value = color;
                updateMenuButtonColor(color);
            }
        }

        function updateHorizontalMovement(value) {
            horizontalMovement = parseInt(value);
            document.getElementById('horizontalMovementValue').textContent = value;
        }

        function updatePrecipitationMode(value) {
            precipitationMode = value;
            const controls = document.getElementById('precipitationControls');
            const denseControls = document.getElementById('denseControls');
            controls.style.display = value !== 'continuous' ? 'block' : 'none';
            denseControls.style.display = value === 'dense' ? 'block' : 'none';
            
            // Reset rain drops for new mode
            rainDrops = Array(Math.ceil(columns)).fill(1);
            lastSpawnTimes = Array(Math.ceil(columns)).fill(Date.now());
            currentColumn = 0;
            initializeColumns();
        }

        function updateSpawnDelay(value) {
            spawnDelay = parseInt(value);
            document.getElementById('spawnDelayValue').textContent = (value / 1000).toFixed(1) + 's';
        }

        function updateLineSpacing(value) {
            lineSpacing = parseInt(value);
            document.getElementById('lineSpacingValue').textContent = value;
        }

        function toggleMovement(enabled) {
            movementEnabled = enabled;
            const controls = document.getElementById('movementControls');
            controls.style.display = enabled ? 'block' : 'none';
            
            if (!enabled) {
                // Reset to normal rain
                precipitationMode = 'continuous';
                horizontalMovement = 0;
                document.getElementById('precipitationSelect').value = 'continuous';
                document.getElementById('horizontalMovementSlider').value = '0';
                document.getElementById('horizontalMovementValue').textContent = '0';
                rainDrops = Array(Math.ceil(columns)).fill(1);
                lastSpawnTimes = Array(Math.ceil(columns)).fill(Date.now());
                currentColumn = 0;
            }
            initializeColumns();
        }

        function updateDensity(value) {
            density = parseInt(value);
            document.getElementById('densityValue').textContent = value;
            
            // Adjust font size based on density
            const baseFontSize = 16;
            const scaleFactor = 1 + ((10 - density) / 100); // ±15% max adjustment
            fontSize = Math.round(baseFontSize * scaleFactor);
            
            // Recalculate columns and reinitialize
            columns = canvas.width / fontSize;
            rainDrops = Array(Math.ceil(columns)).fill(1);
            rainDropsChars = Array(Math.ceil(columns)).fill().map(() => getRandomSelectedChar());
            initializeColumns();
        }

        function adjustDensity(baseSpacing, mode) {
            const densityFactor = density / 5; // normalize to 1 at density=5
            let spacing = baseSpacing;
            
            if (mode === 'dense') {
                spacing *= 3 * densityFactor; // Increased spacing for dense mode
                spacing = Math.max(3, spacing); // Increased minimum gap
            } else {
                spacing *= densityFactor;
            }
            
            return spacing;
        }

        function calculateColumnMovement(index, time, horizontalIntensity) {
            if (horizontalIntensity === 0) return 0;
            
            const maxOffset = movementRange; // Use custom range instead of fontSize * 0.15
            let offset = 0;
            
            if (horizontalIntensity <= 5) {
                // Coordinated group sway - groups of 3 columns move together
                const groupIndex = Math.floor(index / 3);
                const frequency = 0.5 + (horizontalIntensity * 0.1);
                const amplitude = (horizontalIntensity / 5) * maxOffset;
                offset = Math.sin(time * frequency + columnPhases[groupIndex]) * amplitude;
            } else {
                // Chaotic individual drift
                const frequency = 0.5 + ((horizontalIntensity - 5) * 0.2);
                const amplitude = ((horizontalIntensity - 5) / 5) * maxOffset;
                offset = Math.sin(time * frequency + columnPhases[index]) * amplitude;
                
                // Add secondary chaotic movement
                offset += Math.sin(time * frequency * 1.5 + columnPhases[index] * 2) * (amplitude * 0.3);
            }
            
            return offset;
        }

        function updateMovementRange(value) {
            movementRange = Math.max(1, parseInt(value) || 15); // Ensure positive value, default to 15
            document.getElementById('movementRangeInput').value = movementRange;
        }

        function updateDensePack(value) {
            densePack = parseInt(value);
            document.getElementById('densePackValue').textContent = value;
        }

        function updateTrailChars(value) {
            trailChars = parseInt(value);
            document.getElementById('trailCharValue').textContent = value;
        }

        function updateLineVariation(value) {
            lineVariation = parseInt(value);
            document.getElementById('lineVariationValue').textContent = value + '%';
            initializeColumns();
        }

        function getRandomSelectedChar() {
            const chars = Array.from(selectedChars);
            return chars[Math.floor(Math.random() * chars.length)];
        }

        // Add waterfall mode functions
        function toggleWaterfall(checked) {
            waterfallEnabled = checked;
            const controls = document.getElementById('waterfallControls');
            controls.style.display = checked ? 'block' : 'none';
            
            if (checked) {
                // Reset all columns to start from top when waterfall is enabled
                for (let i = 0; i < rainDrops.length; i++) {
                    rainDrops[i] = 0;
                    if (sequenceEnabled) {
                        const selectedCharsArray = Array.from(selectedChars);
                        switch (sequenceMode) {
                            case 'random':
                                rainDropsChars[i] = selectedCharsArray[Math.floor(Math.random() * selectedCharsArray.length)];
                                break;
                            case 'orderly':
                                const position = Math.floor(i / trailLength);
                                rainDropsChars[i] = selectedCharsArray[position % selectedCharsArray.length];
                                break;
                            case 'sequential':
                                if (customSequence) {
                                    const position = Math.floor(i / trailLength);
                                    rainDropsChars[i] = customSequence[position % customSequence.length];
                                }
                                break;
                        }
                    } else {
                        rainDropsChars[i] = getRandomSelectedChar();
                    }
                }
                columnSpeeds = new Array(Math.ceil(columns)).fill(1);
            } else {
                // Reset speeds when disabling waterfall
                columnSpeeds = new Array(Math.ceil(columns)).fill(1);
            }
        }

        function updateWaterfallIntensity(value) {
            waterfallIntensity = parseInt(value);
            document.getElementById('waterfallIntensityValue').textContent = value;
            
            // Reset positions when intensity is set to 50 to restore perfect unison
            if (waterfallIntensity === 50) {
                for (let i = 0; i < rainDrops.length; i++) {
                    rainDrops[i] = 0;
                    if (sequenceEnabled) {
                        const selectedCharsArray = Array.from(selectedChars);
                        switch (sequenceMode) {
                            case 'random':
                                rainDropsChars[i] = selectedCharsArray[Math.floor(Math.random() * selectedCharsArray.length)];
                                break;
                            case 'orderly':
                                const position = Math.floor(i / trailLength);
                                rainDropsChars[i] = selectedCharsArray[position % selectedCharsArray.length];
                                break;
                            case 'sequential':
                                if (customSequence) {
                                    const position = Math.floor(i / trailLength);
                                    rainDropsChars[i] = customSequence[position % customSequence.length];
                                }
                                break;
                        }
                    } else {
                        rainDropsChars[i] = getRandomSelectedChar();
                    }
                }
            }
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
    </script>
</body>
</html>